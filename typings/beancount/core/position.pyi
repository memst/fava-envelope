"""
This type stub file was generated by pyright.
"""

import datetime
from decimal import Decimal
from typing import NamedTuple, Optional, Self

from beancount.core.amount import Amount

"""A position object, which consists of units Amount and cost Cost.

See types below for details.
"""

__copyright__ = ...
__license__ = ...

# A variant of Amount that also includes a date and a label.
#
# Attributes:
#   number: A Decimal, the per-unit cost.
#   currency: A string, the cost currency.
#   date: A datetime.date for the date that the lot was created at. There
#      should always be a valid date.
#   label: A string for the label of this lot, or None, if there is no label.
Cost = NamedTuple(
    "Cost",
    [
        ("number", Decimal),
        ("currency", str),
        ("date", datetime.date),
        ("label", Optional[str]),
    ],
)

# A stand-in for an "incomplete" Cost, that is, a container all the data that
# was provided by the user in the input in order to resolve this lot to a
# particular lot and produce an instance of Cost. Any of the fields of this
# object may be left unspecified, in which case they take the special value
# "NA" (see below), if the field was absent from the input.
#
# Attributes:
#   number_per: A Decimal instance, the cost/price per unit, or None if unspecified.
#   number_total: A Decimal instance, the total cost/price, or None if unspecified.
#   currency: A string, the commodity of the amount, or None if unspecified.
#   date: A datetime.date, or None if unspecified.
#   label: A string for the label of this lot, or None if unspecified.
#   merge: A boolean, true if this specification calls for averaging the units
#      of this lot's currency, or False if unspecified.
CostSpec = NamedTuple(
    "CostSpec",
    [
        ("number_per", Optional[Decimal]),
        ("number_total", Optional[Decimal]),
        ("currency", Optional[str]),
        ("date", Optional[datetime.date]),
        ("label", Optional[str]),
        ("merge", Optional[bool]),
    ],
)

def cost_to_str(cost, dformat, detail=...):  # -> LiteralString:
    """Format an instance of Cost or a CostSpec to a string.

    Args:
      cost: An instance of Cost or CostSpec.
      dformat: A DisplayFormatter object.
      detail: A boolean, true if we should render the non-amount components.
    Returns:
      A string, suitable for formatting.
    """
    ...

CURRENCY_ORDER = ...
NCURRENCIES = ...

def get_position(posting):  # -> Position:
    """Build a Position instance from a Posting instance.

    Args:
      posting: An instance of Posting.
    Returns:
      An instance of Position.
    """
    ...

def to_string(pos, dformat=..., detail=...):  # -> str:
    """Render the Position or Posting instance to a string.

    Args:
      pos: An instance of Position or Posting.
      dformat: An instance of DisplayFormatter.
      detail: A boolean, true if we should only render the lot details
       beyond the cost (lot-date, label, etc.). If false, we only render
       the cost, if present.
    Returns:
      A string, the rendered position.
    """
    ...

_Position = ...

class Position(_Position):
    """A 'Position' is a pair of units and optional cost.
    This is used to track inventories.

    Attributes:
      units: An Amount, the number of units and its currency.
      cost: A Cost that represents the lot, or None.
    """

    units: Amount
    cost: Cost | CostSpec | None
    __slots__ = ...
    cost_types = ...
    def __new__(cls, units: Amount, cost: Cost | CostSpec | None) -> Self: ...
    def __hash__(self) -> int:
        """Compute a hash for this position.

        Returns:
          A hash of this position object.
        """
        ...

    def to_string(self, dformat=..., detail=...):  # -> str:
        """Render the position to a string.See to_string() for details."""
        ...

    def __str__(self) -> str:
        """Return a string representation of the position.

        Returns:
          A string, a printable representation of the position.
        """
        ...

    __repr__ = ...
    def __eq__(self, other) -> bool:
        """Equality comparison with another Position. The objects are considered equal
        if both number and lot are matching, and if the number of units is zero
        and the other position is None, that is also okay.

        Args:
          other: An instance of Position, or None.
        Returns:
          A boolean, true if the positions are equal.
        """
        ...

    def sortkey(self):  # -> tuple[int, Decimal, str, Decimal | None]:
        """Return a key to sort positions by. This key depends on the order of the
        currency of the lot (we want to order common currencies first) and the
        number of units.

        Returns:
          A tuple, used to sort lists of positions.
        """
        ...

    def __lt__(self, other) -> bool:
        """A less-than comparison operator for positions.

        Args:
          other: Another instance of Position.
        Returns:
          True if this positions is smaller than the other position.
        """
        ...

    def __copy__(self):  # -> Position:
        """Shallow copy, except for the lot, which can be shared. This is important for
        performance reasons; a lot of time is spent here during balancing.

        Returns:
          A shallow copy of this position.
        """
        ...

    def currency_pair(self):  # -> tuple[str, str | None]:
        """Return the currency pair associated with this position.

        Returns:
          A pair of a currency string and a cost currency string or None.
        """
        ...

    def get_negative(self):  # -> Position:
        """Get a copy of this position but with a negative number.

        Returns:
          An instance of Position which represents the inverse of this Position.
        """
        ...

    __neg__ = ...
    def __abs__(self):  # -> Position:
        """Return the absolute value of the position.

        Returns:
          An instance of Position with the absolute units.
        """
        ...

    def __mul__(self, scalar):  # -> Position:
        """Scale/multiply the contents of the position.

        Args:
          scalar: A Decimal.
        Returns:
          An instance of Inventory.
        """
        ...

    def is_negative_at_cost(self):  # -> bool:
        """Return true if the position is held at cost and negative.

        Returns:
          A boolean.
        """
        ...

    @staticmethod
    def from_string(string):  # -> Position:
        """Create a position from a string specification.

        This is a miniature parser used for building tests.

        Args:
          string: A string of <number> <currency> with an optional {<number>
            <currency>} for the cost, similar to the parser syntax.
        Returns:
          A new instance of Position.
        """
        ...

    @staticmethod
    def from_amounts(units, cost_amount=...):  # -> Position:
        """Create a position from an amount and a cost.

        Args:
          amount: An amount, that represents the number of units and the lot currency.
          cost_amount: If not None, represents the cost amount.
        Returns:
          A Position instance.
        """
        ...

from_string = ...
from_amounts = ...
