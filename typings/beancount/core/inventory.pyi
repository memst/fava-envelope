"""
This type stub file was generated by pyright.
"""

import enum
from decimal import Decimal
from typing import Iterator, overload

from beancount.core.amount import Amount
from beancount.core.data import Posting
from beancount.core.position import Cost, Position

"""A container for an inventory of positions.

This module provides a container class that can hold positions. An inventory is
a mapping of positions, where each position is keyed by

  (currency: str, cost: Cost) -> position: Position

where

  'currency': The commodity under consideration, USD, CAD, or stock units such
     as HOOL, MSFT, AAPL, etc.;

  'cost': None or a Cost instance existing of cost currency, number, date, and
     label;

  'position': A Position object, whose 'units' attribute is guaranteed to have
    the same currency as 'currency' and whose 'cost' attribute is equal to the
    'cost' key. It basically stores the number of units.

This is meant to accommodate both booked and non-booked amounts. The clever
trick that we pull to do this is that for positions which aren't booked, we
simply leave the 'cost' as None. This is the case for most of the transactions.

= Conversions =

If it often desired to convert this inventory into an equivalent position for
its cost, or to just flatten all the positions with the same currency and count
the number of units, or to compute the market value for the inventory at a
specific date. You do these conversions using the reduce() method:

  inventory.reduce(convert.get_cost)
  inventory.reduce(convert.get_units)
  inventory.reduce(convert.get_value, price_map, date)

"""
__copyright__ = ...
__license__ = ...
ASSERTS_TYPES = ...

class Booking(enum.Enum):
    """Result of booking a new lot to an existing inventory."""

    CREATED = ...
    REDUCED = ...
    AUGMENTED = ...
    IGNORED = ...

class Inventory(dict):
    """An Inventory is a set of positions.

    Attributes:
      positions: A list of Position instances, held in this Inventory object.
    """
    def __init__(self, positions=...) -> None:
        """Create a new inventory using a list of existing positions.

        Args:
          positions: A list of Position instances or an existing dict or
            Inventory instance.
        """
        ...

    def __iter__(self) -> Iterator[Position]:
        """Iterate over the positions. Note that there is no guaranteed order."""
        ...

    def __lt__(self, other: Inventory) -> bool:
        """Inequality comparison operator."""
        ...

    def to_string(self, dformat=..., parens=...):  # -> LiteralString:
        """Convert an Inventory instance to a printable string.

        Args:
          dformat: An instance of DisplayFormatter.
          parents: A boolean, true if we should surround the results by parentheses.
        Returns:
          A formatted string of the quantized amount and symbol.
        """
        ...

    def __str__(self) -> str:
        """Render as a human-readable string.

        Returns:
          A string, for human consumption.
        """
        ...

    __repr__ = ...
    def is_empty(self):  # -> bool:
        """Return true if the inventory is empty, that is, has no positions.

        Returns:
          A boolean.
        """
        ...

    def __bool__(self): ...
    def __copy__(self):  # -> Inventory:
        """A shallow copy of this inventory object.

        Returns:
          An instance of Inventory, equal to this one.
        """
        ...

    def is_small(self, tolerances):  # -> bool:
        """Return true if all the positions in the inventory are small.

        Args:
          tolerances: A Decimal, the small number of units under which a position
            is considered small, or a dict of currency to such epsilon precision.
        Returns:
          A boolean.
        """
        ...

    def is_mixed(self):  # -> bool:
        """Return true if the inventory contains a mix of positive and negative lots for
        at least one instrument.

        Returns:
          A boolean.
        """
        ...

    def is_reduced_by(self, ramount):  # -> bool:
        """Return true if the amount could reduce this inventory.

        Args:
          ramount: An instance of Amount.
        Returns:
          A boolean.
        """
        ...

    def __neg__(self) -> Inventory:
        """Return an inventory with the negative of values of this one.

        Returns:
          An instance of Inventory.
        """
        ...

    def __abs__(self):  # -> Inventory:
        """Return an inventory with the absolute value of each position.

        Returns:
          An instance of Inventory.
        """
        ...

    def __mul__(self, scalar: Decimal):  # -> Inventory:
        """Scale/multiply the contents of the inventory.

        Args:
          scalar: A Decimal.
        Returns:
          An instance of Inventory.
        """
        ...

    def currencies(self):  # -> set[Any]:
        """Return the list of unit currencies held in this inventory.

        Returns:
          A list of currency strings.
        """
        ...

    def cost_currencies(self):  # -> set[Any]:
        """Return the list of unit currencies held in this inventory.

        Returns:
          A set of currency strings.
        """
        ...

    def currency_pairs(self):  # -> set[Any]:
        """Return the commodities held in this inventory.

        Returns:
          A set of currency strings.
        """
        ...

    def get_positions(self):  # -> list[Any]:
        """Return the positions in this inventory.

        Returns:
          A shallow copy of the list of positions.
        """
        ...

    def get_only_position(self):  # -> None:
        """Return the first position and assert there are no more.
        If the inventory is empty, return None.
        """
        ...

    def get_currency_units(self, currency) -> Amount:
        """Fetch the total amount across all the position in the given currency.
        This may sum multiple lots in the same currency denomination.

        Args:
          currency: A string, the currency to filter the positions with.
        Returns:
          An instance of Amount, with the given currency.
        """
        ...

    def segregate_units(self, currencies):  # -> dict[Any, Inventory]:
        """Split up the list of positions to the given currencies.

        Args:
          currencies: A list of currency strings, the currencies to isolate.
        Returns:
          A dict of currency to Inventory instances.
        """
        ...

    def split(self):  # -> dict[Any, Inventory]:
        """Split up the list of positions to their corresponding currencies.

        Returns:
          A dict of currency to Inventory instances.
        """
        ...

    def reduce(self, reducer, *args):  # -> Inventory:
        """Reduce an inventory using one of the conversion functions.

        See functions in beancount.core.convert.

        Returns:
          An instance of Inventory.
        """
        ...

    def average(self):  # -> Inventory:
        """Average all lots of the same currency together.

        Use the minimum date from each aggregated set of lots.

        Returns:
          An instance of Inventory.
        """
        ...

    @overload
    def add_amount(self, units: Amount): ...
    @overload
    def add_amount(
        self, units: Amount, cost: None | Cost
    ):  # -> tuple[Any, Literal[Booking.REDUCED, Booking.AUGMENTED, Booking.IGNORED, Booking.CREATED]]:
        """Add to this inventory using amount and cost. This adds with strict lot
        matching, that is, no partial matches are done on the arguments to the
        keys of the inventory.

        Args:
          units: An Amount instance to add.
          cost: An instance of Cost or None, as a key to the inventory.
        Returns:
          A pair of (position, booking) where 'position' is the position that
          that was modified BEFORE it was modified, and where 'booking' is a
          Booking enum that hints at how the lot was booked to this inventory.
          Position may be None if there is no corresponding Position object,
          e.g. the position was deleted.
        """
        ...

    def add_position(
        self, position: Position | Posting
    ):  # -> tuple[Any, Literal[Booking.REDUCED, Booking.AUGMENTED, Booking.IGNORED, Booking.CREATED]]:
        """Add using a position (with strict lot matching).
        Return True if this position was booked against and reduced another.

        Args:
          position: The Posting or Position to add to this inventory.
        Returns:
          A pair of (position, booking) where 'position' is the position that
          that was modified, and where 'booking' is a Booking enum that hints at
          how the lot was booked to this inventory.
        """
        ...

    def add_inventory(self, other):  # -> Self:
        """Add all the positions of another Inventory instance to this one.

        Args:
          other: An instance of Inventory to add to this one.
        Returns:
          This inventory, modified.
        """
        ...

    def __add__(self, other):  # -> Inventory:
        """Add another inventory to this one. This inventory is not modified.

        Args:
          other: An instance of Inventory.
        Returns:
          A new instance of Inventory.
        """
        ...

    __iadd__ = ...
    @staticmethod
    def from_string(string):  # -> Inventory:
        """Create an Inventory from a string. This is useful for writing tests.

        Args:
          string: A comma-separated string of <number> <currency> with an
            optional {<number> <currency>} for the cost.
        Returns:
          A new instance of Inventory with the given balances.
        """
        ...

from_string = ...

def check_invariants(inv):  # -> None:
    """Check the invariants of the Inventory.

    Args:
      inventory: An instance of Inventory.
    Returns:
      True if the invariants are respected.
    """
    ...
