"""
This type stub file was generated by pyright.
"""

import datetime
import enum
from typing import Any, Dict, Generator, List, NamedTuple, Optional, Tuple, Union

from beancount.core.amount import Amount
from beancount.parser.grammar import ValueType

"""Basic data structures used to represent the Ledger entries.
"""
__copyright__ = ...
__license__ = ...
Account = str
Currency = str
Flag = str
Meta = Dict[str, Any]
EMPTY_SET = ...

@enum.unique
class Booking(enum.Enum):
    STRICT = ...
    NONE = ...
    AVERAGE = ...
    FIFO = ...
    LIFO = ...
    HIFO = ...

def new_directive(clsname, fields: List[Tuple]) -> NamedTuple:
    """Create a directive class. Do not include default fields.
    This should probably be carried out through inheritance.

    Args:
      name: A string, the capitalized name of the directive.
      fields: A string or the list of strings, names for the fields
        to add to the base tuple.
    Returns:
      A type object for the new directive type.
    """
    ...

Open = ...
Close = ...
Commodity = ...
Pad = ...
Balance = ...
Posting = NamedTuple(
    "Posting",
    [
        ("account", Account),
        ("units", Amount),
        ("cost", Optional[Union[Any, Any]]),  # Cost, CostSpec
        ("price", Optional[Amount]),
        ("flag", Optional[Flag]),
        ("meta", Optional[Meta]),
    ],
)
TxnPosting = ...
Note = ...
Event = ...
Query = ...
Price = ...
Document = ...

class _BaseDirective(NamedTuple):
    meta: Meta
    date: datetime.date

class Custom(_BaseDirective):
    type: str
    values: List[ValueType]

class Transaction(_BaseDirective):
    flag: Flag
    payee: str | None
    narration: str
    tags: set
    links: set
    postings: list[Posting]

ALL_DIRECTIVES = ...

class Directive: ...

Entries = List[Directive]
Options = Dict[str, Any]

def new_metadata(filename, lineno, kvlist=...):  # -> dict[str, Any]:
    """Create a new metadata container from the filename and line number.

    Args:
      filename: A string, the filename for the creator of this directive.
      lineno: An integer, the line number where the directive has been created.
      kvlist: An optional container of key-values.
    Returns:
      A metadata dict.
    """
    ...

def create_simple_posting(entry, account, number, currency):  # -> Posting:
    """Create a simple posting on the entry, with just a number and currency (no cost).

    Args:
      entry: The entry instance to add the posting to.
      account: A string, the account to use on the posting.
      number: A Decimal number or string to use in the posting's Amount.
      currency: A string, the currency for the Amount.
    Returns:
      An instance of Posting, and as a side-effect the entry has had its list of
      postings modified with the new Posting instance.
    """
    ...

def create_simple_posting_with_cost(
    entry, account, number, currency, cost_number, cost_currency
):  # -> Posting:
    """Create a simple posting on the entry, with just a number and currency (no cost).

    Args:
      entry: The entry instance to add the posting to.
      account: A string, the account to use on the posting.
      number: A Decimal number or string to use in the posting's Amount.
      currency: A string, the currency for the Amount.
      cost_number: A Decimal number or string to use for the posting's cost Amount.
      cost_currency: a string, the currency for the cost Amount.
    Returns:
      An instance of Posting, and as a side-effect the entry has had its list of
      postings modified with the new Posting instance.
    """
    ...

NoneType = ...

def sanity_check_types(entry, allow_none_for_tags_and_links=...):  # -> None:
    """Check that the entry and its postings has all correct data types.

    Args:
      entry: An instance of one of the entries to be checked.
      allow_none_for_tags_and_links: A boolean, whether to allow plugins to
        generate Transaction objects with None as value for the 'tags' or 'links'
        attributes.
    Raises:
      AssertionError: If there is anything that is unexpected, raises an exception.
    """
    ...

def posting_has_conversion(posting):  # -> bool:
    """Return true if this position involves a conversion.

    A conversion is when there is a price attached to the amount but no cost.
    This is used on transactions to convert between units.

    Args:
      posting: an instance of Posting
    Return:
      A boolean, true if this posting has a price conversion.
    """
    ...

def transaction_has_conversion(transaction):  # -> bool:
    """Given a Transaction entry, return true if at least one of
    the postings has a price conversion (without an associated
    cost). These are the source of non-zero conversion balances.

    Args:
      transaction: an instance of a Transaction entry.
    Returns:
      A boolean, true if this transaction contains at least one posting with a
      price conversion.
    """
    ...

def get_entry(posting_or_entry):  # -> NamedTuple:
    """Return the entry associated with the posting or entry.

    Args:
      entry: A TxnPosting or entry instance
    Returns:
      A datetime instance.
    """
    ...

SORT_ORDER = ...

def entry_sortkey(entry):  # -> tuple[Any, Any, Any]:
    """Sort-key for entries. We sort by date, except that checks
    should be placed in front of every list of entries of that same day,
    in order to balance linearly.

    Args:
      entry: An entry instance.
    Returns:
      A tuple of (date, integer, integer), that forms the sort key for the
      entry.
    """
    ...

def sorted(entries):  # -> list[Any]:
    """A convenience to sort a list of entries, using entry_sortkey().

    Args:
      entries: A list of directives.
    Returns:
      A sorted list of directives.
    """
    ...

def posting_sortkey(entry):  # -> tuple[Any, Any, Any]:
    """Sort-key for entries or postings. We sort by date, except that checks
    should be placed in front of every list of entries of that same day,
    in order to balance linearly.

    Args:
      entry: A Posting or entry instance
    Returns:
      A tuple of (date, integer, integer), that forms the sort key for the
      posting or entry.
    """
    ...

def filter_txns(entries) -> Generator[Transaction, None, None]:
    """A generator that yields only the Transaction instances.

    This is such an incredibly common operation that it deserves a terse
    filtering mechanism.

    Args:
      entries: A list of directives.
    Yields:
      A sorted list of only the Transaction directives.
    """
    ...

def has_entry_account_component(entry, component):  # -> bool:
    """Return true if one of the entry's postings has an account component.

    Args:
      entry: A Transaction entry.
      component: A string, a component of an account name. For instance,
        ``Food`` in ``Expenses:Food:Restaurant``. All components are considered.
    Returns:
      Boolean: true if the component is in the account. Note that a component
      name must be whole, that is ``NY`` is not in ``Expenses:Taxes:StateNY``.
    """
    ...

def find_closest(entries, filename, lineno):  # -> None:
    """Find the closest entry from entries to (filename, lineno).

    Args:
      entries: A list of directives.
      filename: A string, the name of the ledger file to look for. Be careful
        to provide the very same filename, and note that the parser stores the
        absolute path of the filename here.
      lineno: An integer, the line number closest after the directive we're
        looking for. This may be the exact/first line of the directive.
    Returns:
      The closest entry found in the given file for the given filename, or
      None, if none could be found.
    """
    ...

def remove_account_postings(account, entries):  # -> list[Any]:
    """Remove all postings with the given account.

    Args:
      account: A string, the account name whose postings we want to remove.
    Returns:
      A list of entries without the rounding postings.
    """
    ...

def iter_entry_dates(entries, date_begin, date_end):  # -> Generator[Any, Any, None]:
    """Iterate over the entries in a date window.

    Args:
      entries: A date-sorted list of dated directives.
      date_begin: A datetime.date instance, the first date to include.
      date_end: A datetime.date instance, one day beyond the last date.
    Yields:
      Instances of the dated directives, between the dates, and in the order in
      which they appear.
    """
    ...
