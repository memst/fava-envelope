"""
This type stub file was generated by pyright.
"""

import cmd

"""
This type stub file was generated by pyright.
"""
__copyright__ = ...
__license__ = ...
HISTORY_FILENAME = ...
def load_history(filename):
    """Load the shell's past history.

    Args:
      filename: A string, the name of the file containing the shell history.
    """
    ...

def save_history(filename):
    """Save the shell history. This should be invoked on exit.

    Args:
      filename: A string, the name of the file to save the history to.
    """
    ...

def get_history(max_entries):
    """Return the history in the readline buffer.

    Args:
      max_entries: An integer, the maximum number of entries to return.
    Returns:
      A list of string, the previous history of commands.
    """
    ...

def convert_bool(string):
    """Convert a string to a boolean.

    Args:
      string: A string representing a boolean.
    Returns:
      The corresponding boolean.
    """
    ...

class DispatchingShell(cmd.Cmd):
    """A usable convenient shell for interpreting commands, with history."""
    max_entries = ...
    doc_header = ...
    misc_header = ...
    def __init__(self, is_interactive, parser, outfile, default_format, do_numberify) -> None:
        """Create a shell with history.

        Args:
          is_interactive: A boolean, true if this serves an interactive tty.
          parser: A command parser.
          outfile: An output file object to write communications to.
          default_format: A string, the default output format.
        """
        ...
    
    def initialize_vars(self, default_format, do_numberify):
        """Initialize the setting variables of the interactive shell."""
        ...
    
    def add_help(self):
        "Attach help functions for each of the parsed token handlers."
        ...
    
    def get_pager(self):
        """Create and return a context manager to write to, a pager subprocess if required.

        Returns:
          A pair of a file object to write to, and a pipe object to wait on (or
        None if not necessary to wait).
        """
        ...
    
    def cmdloop(self):
        """Override cmdloop to handle keyboard interrupts."""
        ...
    
    def do_help(self, command):
        """Strip superfluous semicolon."""
        ...
    
    def do_history(self, _):
        "Print the command-line history statement."
        ...
    
    def do_clear(self, _):
        "Clear the history."
        ...
    
    def do_set(self, line):
        "Get/set shell settings variables."
        ...
    
    def do_lex(self, line):
        "Just run the lexer on the following command and print the output."
        ...
    
    do_tokenize = ...
    def do_parse(self, line):
        "Just run the parser on the following command and print the output."
        ...
    
    def dispatch(self, statement):
        """Dispatch the given statement to a suitable method.

        Args:
          statement: An instance provided by the parser.
        Returns:
          Whatever the invoked method happens to return.
        """
        ...
    
    def default(self, line):
        """Default handling of lines which aren't recognized as native shell commands.

        Args:
          line: The string to be parsed.
        """
        ...
    
    def run_parser(self, line, default_close_date=...):
        """Handle statements via our parser instance and dispatch to appropriate methods.

        Args:
          line: The string to be parsed.
          default_close_date: A datetimed.date instance, the default close date.
        """
        ...
    
    def emptyline(self):
        """Do nothing on an empty line."""
        ...
    
    def exit(self, _):
        """Exit the parser."""
        ...
    
    do_exit = ...
    do_quit = ...
    do_EOF = ...


class BQLShell(DispatchingShell):
    """An interactive shell interpreter for the Beancount query language.
    """
    prompt = ...
    def __init__(self, is_interactive, loadfun, outfile, default_format=..., do_numberify=...) -> None:
        ...
    
    def on_Reload(self, unused_statement=...):
        """
        Reload the input file without restarting the shell.
        """
        ...
    
    def on_Errors(self, errors_statement):
        """
        Print the errors that occurred during parsing.
        """
        ...
    
    def on_Print(self, print_stmt):
        """
        Print entries in Beancount format.

        The general form of a PRINT statement includes an SQL-like FROM
        selector:

           PRINT [FROM <from_expr> ...]

        Where:

          from_expr: A logical expression that matches on the attributes of
            the directives. See SELECT command for details (this FROM expression
            supports all the same expressions including its OPEN, CLOSE and
            CLEAR operations).

        """
        ...
    
    def on_Select(self, statement):
        """
        Extract data from a query on the postings.

        The general form of a SELECT statement loosely follows SQL syntax, with
        some mild and idiomatic extensions:

           SELECT [DISTINCT] [<targets>|*]
           [FROM <from_expr> [OPEN ON <date>] [CLOSE [ON <date>]] [CLEAR]]
           [WHERE <where_expr>]
           [GROUP BY <groups>]
           [ORDER BY <groups> [ASC|DESC]]
           [LIMIT num]

        Where:

          targets: A list of desired output attributes from the postings, and
            expressions on them. Some of the attributes of the parent transaction
            directive are made available in this context as well. Simple functions
            (that return a single value per row) and aggregation functions (that
            return a single value per group) are available. For the complete
            list of supported columns and functions, see help on "targets".
            You can also provide a wildcard here, which will select a reasonable
            default set of columns for rendering a journal.

          from_expr: A logical expression that matches on the attributes of
            the directives (not postings). This allows you to select a subset of
            transactions, so the accounting equation is respected for balance
            reports. For the complete list of supported columns and functions,
            see help on "from".

          where_expr: A logical expression that matches on the attributes of
            postings. The available columns are similar to those in the targets
            clause, without the aggregation functions.

          OPEN clause: replace all the transactions before the given date by
            summarizing entries and transfer Income and Expenses balances to
            Equity.

          CLOSE clause: Remove all the transactions after the given date and

          CLEAR: Transfer final Income and Expenses balances to Equity.

        """
        ...
    
    def on_Journal(self, journal):
        """
        Select a journal of some subset of postings. This command is a
        convenience and converts into an equivalent Select statement, designed
        to extract the most sensible list of columns for the register of a list
        of entries as a table.

        The general form of a JOURNAL statement loosely follows SQL syntax:

           JOURNAL <account-regexp> [FROM_CLAUSE]

        See the SELECT query help for more details on the FROM clause.
        """
        ...
    
    def on_Balances(self, balance):
        """
        Select balances of some subset of postings. This command is a
        convenience and converts into an equivalent Select statement, designed
        to extract the most sensible list of columns for the register of a list
        of entries as a table.

        The general form of a JOURNAL statement loosely follows SQL syntax:

           BALANCE [FROM_CLAUSE]

        See the SELECT query help for more details on the FROM clause.
        """
        ...
    
    def on_Explain(self, explain):
        """
        Compile and print a compiled statement for debugging.
        """
        ...
    
    def on_RunCustom(self, run_stmt):
        """
        Run a custom query instead of a SQL command.

           RUN <custom-query-name>

        Where:

          custom-query-name: Should be the name of a custom query to be defined
            in the Beancount input file.

        """
        ...
    
    def help_targets(self):
        ...
    
    def help_from(self):
        ...
    
    def help_where(self):
        ...
    
    def help_attributes(self):
        ...
    


def generate_env_attribute_list(env):
    """Generate a dictionary of rendered attribute lists for help.

    Args:
      env: An instance of an environment.
    Returns:
      A dict with keys 'columns', 'functions' and 'aggregates' to rendered
      and formatted strings.
    """
    ...

def generate_env_attributes(wrapper, field_dict, filter_pred=...):
    """Generate a string of all the help functions of the attributes.

    Args:
      wrapper: A TextWrapper instance to format the paragraphs.
      field_dict: A dict of the field-names to the node instances, fetch from an
        environment.
      filter_pred: A predicate to filter the desired columns. This is applied to
        the evaluator node instances.
    Returns:
      A formatted multiline string, ready for insertion in a help text.
    """
    ...

def summary_statistics(entries):
    """Calculate basic summary statistics to output a brief welcome message.

    Args:
      entries: A list of directives.
    Returns:
      A tuple of three integers, the total number of directives parsed, the total number
      of transactions and the total number of postings there in.
    """
    ...

def print_statistics(entries, options_map, outfile):
    """Print summary statistics to stdout.

    Args:
      entries: A list of directives.
      options_map: An options map. as produced by the parser.
      outfile: A file object to write to.
    """
    ...

def create_custom_query_map(entries):
    """Extract a mapping of the custom queries from the list of entries.

    Args:
      entries: A list of entries.
    Returns:
      A map of query-name strings to Query directives.
    """
    ...

_SUPPORTED_FORMATS = ...
def main():
    ...

if __name__ == '__main__':
    ...
