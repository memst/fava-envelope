"""
This type stub file was generated by pyright.
"""

"""
This type stub file was generated by pyright.
"""
__copyright__ = ...
__license__ = ...
SUPPORT_IMPLICIT_GROUPBY = ...
class CompilationError(Exception):
    """A compiler/interpreter error."""
    ...


class EvalNode:
    __slots__ = ...
    def __init__(self, dtype) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        """Override the equality operator to compare the data type and a all attributes
        of this node. This is used by tests for comparing nodes.
        """
        ...
    
    def __str__(self) -> str:
        ...
    
    __repr__ = ...
    def childnodes(self):
        """Returns the child nodes of this node.
        Yields:
          A list of EvalNode instances.
        """
        ...
    
    def __call__(self, context):
        """Evaluate this node. This is designed to recurse on its children.
        All subclasses must override and implement this method.

        Args:
          context: The evaluation object to which the evaluation need to apply.
            This is either an entry, a Posting instance, or a particular result
            set row from a sub-select. This is the provider for the underlying
            data.
        Returns:
          The evaluated value for this sub-expression tree.
        """
        ...
    


class EvalConstant(EvalNode):
    __slots__ = ...
    def __init__(self, value) -> None:
        ...
    
    def __call__(self, _):
        ...
    


class EvalUnaryOp(EvalNode):
    __slots__ = ...
    def __init__(self, operator, operand, dtype) -> None:
        ...
    
    def __call__(self, context):
        ...
    


class EvalNot(EvalUnaryOp):
    def __init__(self, operand) -> None:
        ...
    


class EvalBinaryOp(EvalNode):
    __slots__ = ...
    def __init__(self, operator, left, right, dtype) -> None:
        ...
    
    def __call__(self, context):
        ...
    


class EvalEqual(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalAnd(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalOr(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalGreater(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalGreaterEq(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalLess(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalLessEq(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalMatch(EvalBinaryOp):
    @staticmethod
    def match(left, right):
        ...
    
    def __init__(self, left, right) -> None:
        ...
    


class EvalContains(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    
    def __call__(self, context):
        ...
    


class EvalMul(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalDiv(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalAdd(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


class EvalSub(EvalBinaryOp):
    def __init__(self, left, right) -> None:
        ...
    


OPERATORS = ...
ANY = ...
class EvalFunction(EvalNode):
    """Base class for all function objects."""
    __slots__ = ...
    __intypes__ = ...
    def __init__(self, operands, dtype) -> None:
        ...
    
    def eval_args(self, context):
        ...
    


class EvalColumn(EvalNode):
    "Base class for all column accessors."
    ...


class EvalAggregator(EvalFunction):
    "Base class for all aggregator evaluator types."
    def allocate(self, allocator):
        """Allocate handles to store data for a node's aggregate storage.

        This is called once before beginning aggregations. If you need any
        kind of per-aggregate storage during the computation phase, get it
        in this method.

        Args:
          allocator: An instance of Allocator, on which you can call allocate() to
            obtain a handle for a slot to store data on store objects later on.
        """
        ...
    
    def initialize(self, store):
        """Initialize this node's aggregate data. If the node is not an aggregate,
        simply initialize the subnodes. Override this method in the aggregator
        if you need data for storage.

        Args:
          store: An object indexable by handles appropriated during allocate().
        """
        ...
    
    def update(self, store, context):
        """Evaluate this node. This is designed to recurse on its children.

        Args:
          store: An object indexable by handles appropriated during allocate().
          context: The object to which the evaluation need to apply (see __call__).
        """
        ...
    
    def finalize(self, store):
        """Finalize this node's aggregate data and return it.

        For aggregate methods, this finalizes the node and returns the final
        value. The context node will be the alloc instead of the context object.

        Args:
          store: An object indexable by handles appropriated during allocate().
        """
        ...
    
    def __call__(self, context):
        """Return the value on evaluation.

        Args:
          context: The evaluation object to which the evaluation need to apply.
            This is either an entry, a Posting instance, or a particular result
            set row from a sub-select. This is the provider for the underlying
            data.
        Returns:
          The final aggregated value.
        """
        ...
    


class CompilationEnvironment:
    """Base class for all compilation contexts. A compilation context provides
    column accessors specific to the particular row objects that we will access.
    """
    context_name = ...
    columns = ...
    functions = ...
    def get_column(self, name):
        """Return a column accessor for the given named column.
        Args:
          name: A string, the name of the column to access.
        """
        ...
    
    def get_function(self, name, operands):
        """Return a function accessor for the given named function.
        Args:
          name: A string, the name of the function to access.
        """
        ...
    


class AttributeColumn(EvalColumn):
    def __call__(self, row):
        ...
    


class ResultSetEnvironment(CompilationEnvironment):
    """An execution context that provides access to attributes from a result set.
    """
    context_name = ...
    def get_column(self, name):
        """Override the column getter to provide a single attribute getter.
        """
        ...
    


def compile_expression(expr, environ):
    """Bind an expression to its execution context.

    Args:
      expr: The root node of an expression.
      environ: An CompilationEnvironment instance.
    Returns:
      The root node of a bound expression.
    """
    ...

def get_columns_and_aggregates(node):
    """Find the columns and aggregate nodes below this tree.

    All nodes under aggregate nodes are ignored.

    Args:
      node: An instance of EvalNode.
    Returns:
      A pair of (columns, aggregates), both of which are lists of EvalNode instances.
        columns: The list of all columns accessed not under an aggregate node.
        aggregates: The list of all aggregate nodes.
    """
    ...

def is_aggregate(node):
    """Return true if the node is an aggregate.

    Args:
      node: An instance of EvalNode.
    Returns:
      A boolean.
    """
    ...

def is_hashable_type(node):
    """Return true if the node is of a hashable type.

    Args:
      node: An instance of EvalNode.
    Returns:
      A boolean.
    """
    ...

def find_unique_name(name, allocated_set):
    """Come up with a unique name for 'name' amongst 'allocated_set'.

    Args:
      name: A string, the prefix of the name to find a unique for.
      allocated_set: A set of string, the set of already allocated names.
    Returns:
      A unique name. 'allocated_set' is unmodified.
    """
    ...

EvalTarget = ...
def compile_targets(targets, environ):
    """Compile the targets and check for their validity. Process wildcard.

    Args:
      targets: A list of target expressions from the parser.
      environ: A compilation context for the targets.
    Returns:
      A list of compiled target expressions with resolved names.
    """
    ...

def compile_group_by(group_by, c_targets, environ):
    """Process a group-by clause.

    Args:
      group_by: A GroupBy instance as provided by the parser.
      c_targets: A list of compiled target expressions.
      environ: A compilation context to be used to evaluate GROUP BY expressions.
    Returns:
      A tuple of
       new_targets: A list of new compiled target nodes.
       group_indexes: If the query is an aggregate query, a list of integer
         indexes to be used for processing grouping. Note that this list may be
         empty (in the case of targets with only aggregates). On the other hand,
         if this is not an aggregated query, this is set to None. So do
         distinguish the empty list vs. None.
    """
    ...

def compile_order_by(order_by, c_targets, environ):
    """Process an order-by clause.

    Args:
      order_by: A OrderBy instance as provided by the parser.
      c_targets: A list of compiled target expressions.
      environ: A compilation context to be used to evaluate ORDER BY expressions.
    Returns:
      A tuple of
       new_targets: A list of new compiled target nodes.
       order_indexes: A list of integer indexes to be used for processing ordering.
    """
    ...

EvalFrom = ...
def compile_from(from_clause, environ):
    """Compiled a From clause as provided by the parser, in the given environment.

    Args:
      select: An instance of query_parser.Select.
      environ: : A compilation context for evaluating entry filters.
    Returns:
      An instance of Query, ready to be executed.
    """
    ...

EvalQuery = ...
def compile_select(select, targets_environ, postings_environ, entries_environ):
    """Prepare an AST for a Select statement into a very rudimentary execution tree.
    The execution tree mostly looks much like an AST, but with some nodes
    replaced with knowledge specific to an execution context and eventually some
    basic optimizations.

    Args:
      select: An instance of query_parser.Select.
      targets_environ: A compilation environment for evaluating targets.
      postings_environ: A compilation environment for evaluating postings filters.
      entries_environ: A compilation environment for evaluating entry filters.
    Returns:
      An instance of EvalQuery, ready to be executed.
    """
    ...

def transform_journal(journal):
    """Translate a Journal entry into an uncompiled Select statement.

    Args:
      journal: An instance of a Journal object.
    Returns:
      An instance of an uncompiled Select object.
    """
    ...

def transform_balances(balances):
    """Translate a Balances entry into an uncompiled Select statement.

    Args:
      balances: An instance of a Balance object.
    Returns:
      An instance of an uncompiled Select object.
    """
    ...

EvalPrint = ...
def compile_print(print_stmt, env_entries):
    """Compile a Print statement.

    Args:
      statement: An instance of query_parser.Print.
      entries_environ: : A compilation environment for evaluating entry filters.
    Returns:
      An instance of EvalPrint, ready to be executed.
    """
    ...

def compile(statement, targets_environ, postings_environ, entries_environ):
    """Prepare an AST any of the statement into an executable statement.

    Args:
      statement: An instance of the parser's Select, Balances, Journal or Print.
      targets_environ: A compilation environment for evaluating targets.
      postings_environ: : A compilation environment for evaluating postings filters.
      entries_environ: : A compilation environment for evaluating entry filters.
    Returns:
      An instance of EvalQuery or EvalPrint, ready to be executed.
    Raises:
      CompilationError: If the statement cannot be compiled, or is not one of the
        supported statements.
    """
    ...

