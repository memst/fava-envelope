"""
This type stub file was generated by pyright.
"""

import contextlib

"""Code to write output to a pager.

This module contains an object accumulates lines up to a minimum and then
decides whether to flush them to the original output directly if under the
threshold (no pager) or creates a pager and flushes the lines to it if above the
threshold and then forwards all future lines to it. The purpose of this object
is to pipe output to a pager only if the number of lines to be printed exceeds a
minimum number of lines.

The contextmanager is intended to be used to pipe output to a pager and wait on
the pager to complete before continuing. Simply write to the file object and
upon exit we close the file object. This also silences broken pipe errors
triggered by the user exiting the sub-process, and recovers from a failing pager
command by just using stdout.
"""
__copyright__ = ...
__license__ = ...
DEFAULT_PAGER = ...
def create_pager(command, file): # -> tuple[TextIOWrapper[_WrappedBuffer] | Any, Popen[bytes] | None]:
    """Try to create and return a pager subprocess.

    Args:
      command: A string, the shell command to run as a pager.
      file: The file object for the pager write to. This is also used as a
        default if we failed to create the pager subprocess.
    Returns:
      A pair of (file, pipe), a file object and an optional subprocess.Popen instance
      to wait on. The pipe instance may be set to None if we failed to create a subprocess.
    """
    ...

class ConditionalPager:
    """A proxy file for a pager that only creates a pager after a minimum number of
    lines has been printed to it.
    """
    def __init__(self, command, minlines=...) -> None:
        """Create a conditional pager.

        Args:
          command: A string, the shell command to run as a pager.
          minlines: If set, the number of lines under which you should not bother starting
            a pager. This avoids kicking off a pager if the screen is high enough to
            render the contents. If the value is unset, always starts a pager (which is
            fine behavior too).
        """
        ...
    
    def __enter__(self): # -> Self:
        """Initialize the context manager and return this instance as it."""
        ...
    
    def flush_accumulated(self, file): # -> None:
        """Flush the existing lines to the newly created pager.
        This also disabled the accumulator.

        Args:
          file: A file object to flush the accumulated data to.
        """
        ...
    
    def write(self, data): # -> None:
        """Write the data out. Overridden from the file object interface.

        Args:
          data: A string, data to write to the output.
        """
        ...
    
    def __exit__(self, type, value, unused_traceback): # -> Literal[True] | None:
        """Context manager exit. This flushes the output to our output file.

        Args:
          type: Optional exception type, as per context managers.
          value: Optional exception value, as per context managers.
          unused_traceback: Optional trace.
        """
        ...
    


@contextlib.contextmanager
def flush_only(fileobj): # -> Generator[Any, Any, None]:
    """A contextmanager around a file object that does not close the file.

    This is used to return a context manager on a file object but not close it.
    We flush it instead. This is useful in order to provide an alternative to a
    pager class as above.

    Args:
      fileobj: A file object, to remain open after running the context manager.
    Yields:
      A context manager that yields this object.
    """
    ...

