"""
This type stub file was generated by pyright.
"""

import datetime
from functools import lru_cache as cache
from decimal import Decimal
from dateutil.relativedelta import relativedelta
from beancount.core import amount, data, inventory, position
from beanquery import query_compile, tables, types

"""Environment object for compiler.

This module contains the various column accessors and function evaluators that
are made available by the query compiler via their compilation context objects.
Define new columns and functions here.
"""
__copyright__ = ...
__license__ = ...
def function(intypes, outtype, pass_row=..., pass_context=..., name=...): # -> Callable[..., Any]:
    ...

def register(name=...): # -> Callable[..., Any]:
    ...

@register('getitem')
class GetItem2(query_compile.EvalFunction):
    __intypes__ = ...
    def __init__(self, context, operands) -> None:
        ...
    
    def __call__(self, row): # -> None:
        ...
    


@register('getitem')
class GetItem3(query_compile.EvalFunction):
    __intypes__ = ...
    def __init__(self, context, operands) -> None:
        ...
    
    def __call__(self, row): # -> None:
        ...
    


def Function(name, args):
    ...

@function([types.Any], bool, name='bool')
def bool_(x): # -> bool:
    """Convert to bool value."""
    ...

@function([int], int, name='int')
@function([bool], int, name='int')
@function([Decimal], int, name='int')
@function([str], int, name='int')
@function([object], int, name='int')
def int_(x): # -> int | None:
    ...

@function([Decimal], Decimal, name='decimal')
@function([int], Decimal, name='decimal')
@function([bool], Decimal, name='decimal')
@function([str], Decimal, name='decimal')
@function([object], Decimal, name='decimal')
def decimal_(x): # -> Decimal | None:
    ...

@function([types.Any], str, name='str')
def str_(x): # -> str:
    ...

@function([datetime.date], datetime.date, name='date')
@function([str], datetime.date, name='date')
@function([object], datetime.date, name='date')
def date_(x): # -> date | None:
    ...

@function([int, int, int], datetime.date, name='date')
def date_from_ymd(year, month, day): # -> date | None:
    """Construct a date with year, month, day arguments."""
    ...

@function([Decimal], Decimal)
@function([amount.Amount], amount.Amount)
@function([position.Position], position.Position)
@function([inventory.Inventory], inventory.Inventory)
def neg(x):
    """Negative value."""
    ...

@function([Decimal], Decimal, name='abs')
@function([position.Position], position.Position, name='abs')
@function([inventory.Inventory], inventory.Inventory, name='abs')
def abs_(x):
    """Absolute value."""
    ...

@function([Decimal, Decimal], Decimal)
@function([Decimal, int], Decimal)
def safediv(x, y): # -> ...:
    """A division operation that traps division by zero exceptions and outputs zero instead."""
    ...

@function([Decimal], Decimal, name='round')
@function([Decimal, int], Decimal, name='round')
@function([int], int, name='round')
@function([int, int], int, name='round')
def round_(num, digits=...):
    """Round the argument."""
    ...

@function([list], int)
@function([set], int)
@function([str], int)
def length(x): # -> int:
    """Compute the length of the argument. This works on sequences."""
    ...

@function([types.Any], str, name='repr')
def repr_(x): # -> str:
    """Convert the argument to a string via repr()."""
    ...

@function([str, int], str)
def maxwidth(x, n): # -> str:
    """Convert the argument to a substring. This can be used to ensure
    maximum width. This will insert ellipsis ([...]) if necessary."""
    ...

@function([str, int, int], str)
def substr(string, start, end):
    """Extract a substring of the argument."""
    ...

@function([str, str, int], str)
def splitcomp(string, delim, index):
    """Split a string and extract one of its components."""
    ...

@function([datetime.date], int)
def year(x):
    """Extract the year from a date."""
    ...

@function([datetime.date], int)
def month(x):
    """Extract the month from a date."""
    ...

@function([datetime.date], int)
def day(x):
    """Extract the day from a date."""
    ...

@function([datetime.date], datetime.date)
def yearmonth(x): # -> date:
    """Extract the year and month from a date."""
    ...

@function([datetime.date], str)
def quarter(x): # -> str:
    """Extract the quarter from a date."""
    ...

@function([datetime.date], str, name='weekday')
def weekday_(x):
    """Extract a 3-letter weekday from a date."""
    ...

@function([], datetime.date)
def today(): # -> date:
    """Today's date"""
    ...

@function([str], str)
@function([str, int], str)
def root(acc, n=...):
    """Get the root name(s) of the account."""
    ...

@function([str], str)
def parent(acc):
    """Get the parent name of the account."""
    ...

@function([str], str)
def leaf(acc):
    """Get the name of the leaf subaccount."""
    ...

@function([str, str], str)
def grep(pattern, string): # -> None:
    """Match a regular expression against a string and return only the matched portion."""
    ...

@function([str, str, int], str)
def grepn(pattern, string, n): # -> None:
    """Match a pattern with subgroups against a string and return the subgroup at the index."""
    ...

@function([str, str, str], str)
def subst(pattern, repl, string):
    """Substitute leftmost non-overlapping occurrences of pattern by replacement."""
    ...

@function([str], str)
def upper(string):
    """Convert string to uppercase."""
    ...

@function([str], str)
def lower(string):
    """Convert string to lowercase."""
    ...

NONENONE = ...
@function([str], datetime.date, pass_context=True)
def open_date(context, acc): # -> None:
    """Get the date of the open directive of the account."""
    ...

@function([str], datetime.date, pass_context=True)
def close_date(context, acc): # -> None:
    """Get the date of the close directive of the account."""
    ...

@function([str], dict, pass_context=True)
@function([str, str], object, pass_context=True)
def open_meta(context, account, key=...): # -> None:
    """Get the metadata dict of the open directive of the account."""
    ...

@function([str], object)
def meta(context, key):
    """Get some metadata key of the posting."""
    ...

@function([str], object)
def entry_meta(context, key):
    """Get some metadata key of the transaction."""
    ...

@function([str], object, pass_row=True)
def any_meta(context, key):
    """Get metadata from the posting or its parent transaction if not present."""
    ...

@function([str], dict, pass_context=True)
@function([str, str], object, pass_context=True)
@function([str], dict, pass_context=True, name='commodity_meta')
@function([str, str], object, pass_context=True, name='commodity_meta')
def currency_meta(context, commodity, key=...): # -> None:
    """Get the metadata dict of the commodity directive of the currency."""
    ...

@function([str], str, pass_context=True)
def account_sortkey(context, acc): # -> str:
    """Get a string to sort accounts in order taking into account the types."""
    ...

@function([str], bool, pass_row=True)
def has_account(context, pattern): # -> bool:
    """True if the transaction has at least one posting matching the regular expression argument."""
    ...

@function([position.Position], amount.Amount, name='units')
def position_units(pos):
    """Get the number of units of a position (stripping cost)."""
    ...

@function([inventory.Inventory], inventory.Inventory, name='units')
def inventory_units(inv):
    """Get the number of units of an inventory (stripping cost)."""
    ...

@function([position.Position], amount.Amount, name='cost')
def position_cost(pos):
    """Get the cost of a position."""
    ...

@function([inventory.Inventory], inventory.Inventory, name='cost')
def inventory_cost(inv):
    """Get the cost of an inventory."""
    ...

@function([amount.Amount, str], amount.Amount, pass_context=True, name='convert')
@function([amount.Amount, str, datetime.date], amount.Amount, pass_context=True, name='convert')
def convert_amount(context, amount_, currency, date=...):
    """Coerce an amount to a particular currency."""
    ...

@function([position.Position, str], amount.Amount, pass_context=True, name='convert')
@function([position.Position, str, datetime.date], amount.Amount, pass_context=True, name='convert')
def convert_position(context, pos, currency, date=...):
    """Coerce an amount to a particular currency."""
    ...

@function([inventory.Inventory, str], inventory.Inventory, pass_context=True, name='convert')
@function([inventory.Inventory, str, datetime.date], inventory.Inventory, pass_context=True, name='convert')
def convert_inventory(context, inv, currency, date=...):
    """Coerce an inventory to a particular currency."""
    ...

@function([position.Position], amount.Amount, pass_context=True, name='value')
@function([position.Position, datetime.date], amount.Amount, pass_context=True, name='value')
def position_value(context, pos, date=...):
    """Convert a position to its cost currency at the market value."""
    ...

@function([inventory.Inventory], inventory.Inventory, pass_context=True, name='value')
@function([inventory.Inventory, datetime.date], inventory.Inventory, pass_context=True, name='value')
def inventory_value(context, inv, date=...):
    """Coerce an inventory to its market value."""
    ...

@function([str, str], Decimal, pass_context=True)
@function([str, str, datetime.date], Decimal, pass_context=True, name='getprice')
def getprice(context, base, quote, date=...): # -> Decimal | None:
    """Fetch a price."""
    ...

@function([amount.Amount], Decimal)
def number(x):
    """Extract the number from an Amount."""
    ...

@function([amount.Amount], str)
@function([amount.Amount], str, name='commodity')
def currency(x):
    """Extract the currency from an Amount."""
    ...

@function([str, set], str)
def findfirst(pattern, values): # -> None:
    """Filter a string sequence by regular expression and return the first match."""
    ...

@function([set], str)
def joinstr(values): # -> str:
    """Join a sequence of strings to a single comma-separated string."""
    ...

@function([str, inventory.Inventory], amount.Amount, name='only')
def only_inventory(currency, inventory_):
    """Get one currency's amount from the inventory."""
    ...

@function([inventory.Inventory], bool, name='empty')
def empty_inventory(inventory_):
    """Determine whether the inventiry is empty."""
    ...

@function([position.Position, str], position.Position, name='filter_currency')
def filter_currency_position(pos, currency): # -> None:
    """Filter an inventory to just the specified currency."""
    ...

@function([inventory.Inventory, str], inventory.Inventory, name='filter_currency')
def filter_currency_inventory(inv, currency): # -> Inventory:
    """Filter an inventory to just the specified currency."""
    ...

@function([Decimal, str], Decimal, pass_context=True)
@function([amount.Amount, str], amount.Amount, pass_context=True)
@function([position.Position, str], position.Position, pass_context=True)
@function([inventory.Inventory, str], inventory.Inventory, pass_context=True)
def possign(context, x, account):
    """Correct sign of an Amount based on the usual balance of associated account."""
    ...

@function([str], datetime.date)
@function([str, str], datetime.date)
def parse_date(string, frmt=...): # -> _Date:
    """Parse date from string."""
    ...

@function([datetime.date, datetime.date], int)
def date_diff(x, y):
    """Calculates the difference (in days) between two dates."""
    ...

@function([datetime.date, int], datetime.date)
def date_add(x, y):
    """Adds/subtracts number of days from the given date."""
    ...

@function([str, datetime.date], datetime.date)
def date_trunc(field, x): # -> date | None:
    """Truncate a date to the specified precision."""
    ...

@function([str, datetime.date], int)
def date_part(field, x): # -> int | None:
    """Extract the specified field from a date."""
    ...

@function([str], relativedelta)
def interval(x): # -> relativedelta | None:
    """Construct a relative time interval."""
    ...

def aggregator(intypes, name=...): # -> Callable[..., Any]:
    ...

@aggregator([types.Asterisk], name='count')
class Count(query_compile.EvalAggregator):
    """Count the number of input rows."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([types.Any], name='count')
class CountArg(query_compile.EvalAggregator):
    """Count the number of non-NULL occurrences of the argument."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([int], name='sum')
class SumInt(query_compile.EvalAggregator):
    """Calculate the sum of the numerical argument."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([Decimal], name='sum')
class SumDecimal(query_compile.EvalAggregator):
    """Calculate the sum of the numerical argument."""
    def update(self, store, context): # -> None:
        ...
    


@aggregator([amount.Amount], name='sum')
class SumAmount(query_compile.EvalAggregator):
    """Calculate the sum of the amount. The result is an Inventory."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([position.Position], name='sum')
class SumPosition(query_compile.EvalAggregator):
    """Calculate the sum of the position. The result is an Inventory."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([inventory.Inventory], name='sum')
class SumInventory(query_compile.EvalAggregator):
    """Calculate the sum of the inventories. The result is an Inventory."""
    def __init__(self, context, operands) -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([types.Any], name='first')
class First(query_compile.EvalAggregator):
    """Keep the first of the values seen."""
    def initialize(self, store): # -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([types.Any], name='last')
class Last(query_compile.EvalAggregator):
    """Keep the last of the values seen."""
    def initialize(self, store): # -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([types.Any], name='min')
class Min(query_compile.EvalAggregator):
    """Compute the minimum of the values."""
    def initialize(self, store): # -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


@aggregator([types.Any], name='max')
class Max(query_compile.EvalAggregator):
    """Compute the maximum of the values."""
    def initialize(self, store): # -> None:
        ...
    
    def update(self, store, context): # -> None:
        ...
    


class Row:
    """A dumb container for information used by a row expression."""
    rowid = ...
    posting = ...
    entry = ...
    def __hash__(self) -> int:
        ...
    
    def __init__(self, entries, options) -> None:
        ...
    


class BeanTable(tables.Table):
    def __init__(self, entries, options, open=..., close=..., clear=...) -> None:
        ...
    
    @classmethod
    def column(cls, dtype, name=..., help=...): # -> Callable[..., Any]:
        ...
    
    def update(self, **kwargs): # -> Self:
        ...
    
    def prepare(self): # -> Any:
        """Filter the entries applying the FROM clause qualifiers OPEN, CLOSE, CLEAR."""
        ...
    


class EntriesTable(BeanTable):
    name = ...
    columns = ...
    def __iter__(self): # -> Generator[Row, Any, None]:
        ...
    


column = ...
@column(str, 'id')
def id_(context):
    """Unique id of a directive."""
    ...

@column(str, 'type')
def type_(context): # -> str:
    """The data type of the directive."""
    ...

@column(str)
def filename(context):
    """The filename where the directive was parsed from or created."""
    ...

@column(int)
def lineno(context):
    """The line number from the file the directive was parsed from."""
    ...

@column(datetime.date)
def date(context):
    """The date of the directive."""
    ...

@column(int)
def year(context):
    """The year of the date year of the directive."""
    ...

@column(int)
def month(context):
    """The year of the date month of the directive."""
    ...

@column(int)
def day(context):
    """The year of the date day of the directive."""
    ...

@column(str)
def flag(context): # -> None:
    """The flag the transaction."""
    ...

@column(str)
def payee(context): # -> None:
    """The payee of the transaction."""
    ...

@column(str)
def narration(context): # -> None:
    """The narration of the transaction."""
    ...

@column(str)
def description(context): # -> LiteralString | None:
    """A combination of the payee + narration of the transaction, if present."""
    ...

@column(set)
def tags(context): # -> None:
    """The set of tags of the transaction."""
    ...

@column(set)
def links(context): # -> None:
    """The set of links of the transaction."""
    ...

@column(dict)
def meta(context):
    ...

class PostingsTable(EntriesTable):
    name = ...
    columns = ...
    wildcard_columns = ...
    def __iter__(self): # -> Generator[Row, Any, None]:
        ...
    


column = ...
@column(str)
def filename(context): # -> None:
    """The ledger where the posting is defined."""
    ...

@column(int)
def lineno(context): # -> None:
    """The line number in the ledger file where the posting is defined."""
    ...

@column(str)
def location(context): # -> str | None:
    """The filename:lineno location where the posting is defined."""
    ...

@column(str)
def flag(context):
    """The flag of the parent transaction for this posting."""
    ...

@column(str)
def payee(context):
    """The payee of the parent transaction for this posting."""
    ...

@column(str)
def narration(context):
    """The narration of the parent transaction for this posting."""
    ...

@column(str)
def description(context): # -> LiteralString:
    "A combination of the payee + narration for the transaction of this posting."
    ...

@column(set)
def tags(context):
    "The set of tags of the parent transaction for this posting."
    ...

@column(set)
def links(context):
    """The set of links of the parent transaction for this posting."""
    ...

@column(str)
def posting_flag(context):
    """The flag of the posting itself."""
    ...

@column(str, 'account')
def account_(context):
    """The account of the posting."""
    ...

@column(set)
def other_accounts(context): # -> list[Any]:
    """The list of other accounts in the transaction, excluding that of this posting."""
    ...

@column(Decimal)
def number(context):
    """The number of units of the posting."""
    ...

@column(str)
def currency(context):
    """The currency of the posting."""
    ...

@column(Decimal)
def cost_number(context): # -> None:
    """The number of cost units of the posting."""
    ...

@column(str)
def cost_currency(context): # -> None:
    """The cost currency of the posting."""
    ...

@column(datetime.date)
def cost_date(context): # -> None:
    """The cost currency of the posting."""
    ...

@column(str)
def cost_label(context): # -> Literal['']:
    """The cost currency of the posting."""
    ...

@column(position.Position, 'position')
def position_(context): # -> Position:
    """The position for the posting. These can be summed into inventories."""
    ...

@column(amount.Amount)
def price(context):
    """The price attached to the posting."""
    ...

@column(amount.Amount)
def weight(context):
    """The computed weight used for this posting."""
    ...

@column(inventory.Inventory)
@cache(maxsize=1)
def balance(context):
    """The balance for the posting. These can be summed into inventories."""
    ...

@column(dict)
def meta(context):
    ...

@column(data.Transaction)
def entry(context):
    ...

def Column(name): # -> None:
    ...

def EntriesEnvironment(): # -> type[EntriesTable]:
    ...

def PostingsEnvironment(): # -> type[PostingsTable]:
    ...

